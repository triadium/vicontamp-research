/*
 * WARNING: this file has been generated by
 * Hime Parser Generator 4.3.0
 */

using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using Hime.Redist;
using Hime.Redist.Parsers;
using UnityEngine;

// Исправил код после генератора для встраивания в Unity
namespace MathExp
{
	/// <summary>
	/// Represents a parser
	/// </summary>
	[GeneratedCodeAttribute("Hime.SDK", "4.3.0")]
	internal class MathExpParser : LRkParser
	{
		/// <summary>
		/// The automaton for this parser
		/// </summary>
		/// 
		private static readonly LRkAutomaton commonAutomaton;

		// Добавил, так как пока генератор по грамматике не умеет генерировать
		// загрузку автоматона из внешних ресурсов, а только из внутренних ресурсов сборки,
		// что в Unity не получается реализовать без вызова специального функционала.
		static MathExpParser() {
			
			TextAsset asset = Resources.Load("MathExpParser") as TextAsset;
			Stream s = new MemoryStream(asset.bytes);
			BinaryReader br = new BinaryReader(s);
			commonAutomaton = new LRkAutomaton(br);
		}

		// Интересно, почему не статичным классом со статичными константами и не перечислением?

		/// <summary>
		/// Contains the constant IDs for the variables and virtuals in this parser
		/// </summary>
		[GeneratedCodeAttribute("Hime.SDK", "4.3.0")]
		public class ID
		{
			/// <summary>
			/// The unique identifier for variable exp_atom
			/// </summary>
			public const int VariableExpAtom = 0x0008;
			/// <summary>
			/// The unique identifier for variable exp_factor
			/// </summary>
			public const int VariableExpFactor = 0x0009;
			/// <summary>
			/// The unique identifier for variable exp_term
			/// </summary>
			public const int VariableExpTerm = 0x000A;
			/// <summary>
			/// The unique identifier for variable exp
			/// </summary>
			public const int VariableExp = 0x000B;
		}
		/// <summary>
		/// The collection of variables matched by this parser
		/// </summary>
		/// <remarks>
		/// The variables are in an order consistent with the automaton,
		/// so that variable indices in the automaton can be used to retrieve the variables in this table
		/// </remarks>
		private static readonly Symbol[] variables = {
			new Symbol(0x0008, "exp_atom"), 
			new Symbol(0x0009, "exp_factor"), 
			new Symbol(0x000A, "exp_term"), 
			new Symbol(0x000B, "exp"), 
			new Symbol(0x0017, "__VAxiom") };
		/// <summary>
		/// The collection of virtuals matched by this parser
		/// </summary>
		/// <remarks>
		/// The virtuals are in an order consistent with the automaton,
		/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
		/// </remarks>
		private static readonly Symbol[] virtuals = {};
		
		// Определил как интерфейс, так как мне нравится так больше

		/// <summary>
		/// Represents a set of semantic actions in this parser
		/// </summary>
		[GeneratedCodeAttribute("Hime.SDK", "4.3.0")]
		public interface IActions
		{
			/// <summary>
			/// The OnNumber semantic action
			/// </summary>
			void OnNumber(Symbol head, SemanticBody body);
			/// <summary>
			/// The OnMult semantic action
			/// </summary>
			void OnMult(Symbol head, SemanticBody body);
			/// <summary>
			/// The OnDiv semantic action
			/// </summary>
			void OnDiv(Symbol head, SemanticBody body);
			/// <summary>
			/// The OnPlus semantic action
			/// </summary>
			void OnPlus(Symbol head, SemanticBody body);
			/// <summary>
			/// The OnMinus semantic action
			/// </summary>
			void OnMinus(Symbol head, SemanticBody body);

		}

		// И "пустышку" для простого парсинга

		/// <summary>
		/// Represents a set of semantic no-actions in this parser
		/// </summary>
		[GeneratedCodeAttribute("Hime.SDK", "4.3.0")]
		private class NoActions: IActions
		{
			public void OnNumber(Symbol head, SemanticBody body) {}			
			public void OnMult(Symbol head, SemanticBody body) {}			
			public void OnDiv(Symbol head, SemanticBody body) {}
			public void OnPlus(Symbol head, SemanticBody body) {}			
			public void OnMinus(Symbol head, SemanticBody body) {}

		}
		/// <summary>
		/// Represents a set of empty semantic actions (do nothing)
		/// </summary>
		private static readonly NoActions noActions = new NoActions();
		/// <summary>
		/// Gets the set of semantic actions in the form a table consistent with the automaton
		/// </summary>
		/// <param name="input">A set of semantic actions</param>
		/// <returns>A table of semantic actions</returns>
		private static SemanticAction[] GetUserActions(IActions input)
		{
			SemanticAction[] result = new SemanticAction[5];
			result[0] = new SemanticAction(input.OnNumber);
			result[1] = new SemanticAction(input.OnMult);
			result[2] = new SemanticAction(input.OnDiv);
			result[3] = new SemanticAction(input.OnPlus);
			result[4] = new SemanticAction(input.OnMinus);
			return result;
		}
		/// <summary>
		/// Gets the set of semantic actions in the form a table consistent with the automaton
		/// </summary>
		/// <param name="input">A set of semantic actions</param>
		/// <returns>A table of semantic actions</returns>
		private static SemanticAction[] GetUserActions(Dictionary<string, SemanticAction> input)
		{
			SemanticAction[] result = new SemanticAction[5];
			result[0] = input["OnNumber"];
			result[1] = input["OnMult"];
			result[2] = input["OnDiv"];
			result[3] = input["OnPlus"];
			result[4] = input["OnMinus"];
			return result;
		}
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		public MathExpParser(MathExpLexer lexer) : base (commonAutomaton, variables, virtuals, GetUserActions(noActions), lexer) { }
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		/// <param name="actions">The set of semantic actions</param>
		public MathExpParser(MathExpLexer lexer, IActions actions) : base (commonAutomaton, variables, virtuals, GetUserActions(actions), lexer) { }
		/// <summary>
		/// Initializes a new instance of the parser
		/// </summary>
		/// <param name="lexer">The input lexer</param>
		/// <param name="actions">The set of semantic actions</param>
		public MathExpParser(MathExpLexer lexer, Dictionary<string, SemanticAction> actions) : base (commonAutomaton, variables, virtuals, GetUserActions(actions), lexer) { }

		/// <summary>
		/// Visitor interface
		/// </summary>
		[GeneratedCodeAttribute("Hime.SDK", "4.3.0")]
		public interface IVisitor
		{
			void OnTerminalSeparator(ASTNode node);
			void OnTerminalNumber(ASTNode node);
			void OnVariableExpAtom(ASTNode node);
			void OnVariableExpFactor(ASTNode node);
			void OnVariableExpTerm(ASTNode node);
			void OnVariableExp(ASTNode node);
		}

		[GeneratedCodeAttribute("Hime.SDK", "4.3.0")]
		public class Visitor: IVisitor
		{
			public virtual void OnTerminalSeparator(ASTNode node) {}
			public virtual void OnTerminalNumber(ASTNode node) {}
			public virtual void OnVariableExpAtom(ASTNode node) {}
			public virtual void OnVariableExpFactor(ASTNode node) {}
			public virtual void OnVariableExpTerm(ASTNode node) {}
			public virtual void OnVariableExp(ASTNode node) {}
		}

		/// <summary>
		/// Walk the AST of a result using a visitor
		/// <param name="result">The parse result</param>
		/// <param name="visitor">The visitor to use</param>
		/// </summary>
		public static void Visit(ParseResult result, IVisitor visitor)
		{
			VisitASTNode(result.Root, visitor);
		}

		/// <summary>
		/// Walk the sub-AST from the specified node using a visitor
		/// </summary>
		/// <param name="node">The AST node to start from</param>
		/// <param name="visitor">The visitor to use</param>
		public static void VisitASTNode(ASTNode node, IVisitor visitor)
		{
			for (int i = 0; i < node.Children.Count; i++)
				VisitASTNode(node.Children[i], visitor);
			switch(node.Symbol.ID)
			{
				case 0x0004: visitor.OnTerminalSeparator(node); break;
				case 0x0007: visitor.OnTerminalNumber(node); break;
				case 0x0008: visitor.OnVariableExpAtom(node); break;
				case 0x0009: visitor.OnVariableExpFactor(node); break;
				case 0x000A: visitor.OnVariableExpTerm(node); break;
				case 0x000B: visitor.OnVariableExp(node); break;
			}
		}
	}
}
